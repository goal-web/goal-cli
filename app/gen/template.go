package gen

import (
	"fmt"
	"github.com/goal-web/supports/logs"
	"log"
	"os"
	"strings"
	"text/template"
)

var defaultTemplate = []byte("{{- define \"model\" -}}\npackage {{ .Package }}\n\nimport (\n    \"encoding/json\"\n    \"github.com/goal-web/supports/logs\"\n    \"github.com/goal-web/contracts\"\n    \"github.com/goal-web/database/table\"\n\t\"github.com/goal-web/migration/migrate\"\n    \"github.com/goal-web/supports/utils\"\n    \"github.com/goal-web/collection\"\n\t\"github.com/spf13/cast\"\n    \"fmt\"\n    {{- if hasMsgComment .Model \"@carbon\" }}\n    \"github.com/golang-module/carbon/v2\"\n    {{- end }}\n    {{- range .Imports }}\n    {{ .Alias }} \"{{ .Pkg }}\"\n    {{- end }}\n)\n\n{{- $modelName := .Model.Name }}\n{{- $rawName := .Model.RawName }}\n{{- $tableName := .Model.TableName }}\n{{- $primaryKey := .Model.PrimaryKey }}\n\nvar (\n    {{- range .Relations }}\n    {{ $rawName }}{{ .Name }}Relation contracts.RelationType = \"{{ .JSONName }}\"\n    {{- end }}\n)\n\n{{ toComments .Model.Name .Model.Comments }}\ntype {{ $modelName }} struct {\n\n  {{- range .Fields }}\n  {{- if hasComment .Comment \"@belongsTo\" }}\n  {{- else }}\n  {{ .Comments }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n  {{- end }}\n\n  _raw contracts.Fields\n  _update contracts.Fields\n  _append contracts.Fields\n  _hidden map[string]struct{}\n\n  _relation_loaded map[contracts.RelationType]struct{}\n  {{- range .Relations }}\n    _{{ .Name }} {{ goType . }}\n  {{- end }}\n}\n\n{{- $define := join $rawName \"Define\" }}\nvar {{ $define }} {{ $rawName }}Static\n\ntype {{ $rawName }}Static struct {\n    TableName string\n\tHidden []string\n\tIndexes []string\n\tWith []contracts.RelationType\n\tAppends map[string]func(model *{{ $modelName }}) any\n\n  {{- range .Fields }}\n  {{ .Name }}Getter func(model *{{ $modelName }}, raw {{ goType . }}) {{ goType . }}\n  {{ .Name }}Setter func(model *{{ $modelName }}, raw {{ goType . }}) {{ goType . }}\n  {{- end }}\n\n  Saving   func(model *{{ $modelName }}) contracts.Exception\n  Saved    func(model *{{ $modelName }})\n  Updating func(model *{{ $modelName }}, fields contracts.Fields) contracts.Exception\n  Updated  func(model *{{ $modelName }}, fields contracts.Fields)\n  Deleting func(model *{{ $modelName }}) contracts.Exception\n  Deleted  func(model *{{ $modelName }})\n  PrimaryKeyGetter func(model *{{ $modelName }}) any\n}\n\nfunc {{ $rawName }}Migrator() migrate.Migrator {\n\treturn func(executor contracts.SqlExecutor) contracts.Exception {\n\t    return migrate.Migrate({{ $define }}.TableName, {{ $define }}.Indexes, {{ $modelName }}{}, executor)\n\t}\n}\n\nfunc init() {\n    {{ $define }}.TableName = \"{{ $tableName }}\"\n    {{ $define }}.Appends = make(map[string]func(model *{{ $modelName }}) any)\n    {{- if hasMsgComment .Model \"@hidden\" }}\n    {{ $define }}.Hidden = append(\n        {{ $define }}.Hidden,\n        {{- range .Fields }}\n            {{- if hasComment .Comment \"@hidden\" }}\n            \"{{ .JSONName }}\",\n            {{- end }}\n        {{- end }}\n     )\n    {{- end }}\n\n    {{- if hasMsgComment .Model \"@with\" }}\n    {{ $define }}.With = append(\n        {{ $define }}.With,\n        {{- range .Relations }}\n            {{- if hasComment .Comment \"@with\" }}\n             {{ $rawName }}{{ .Name }}Relation,\n            {{- end }}\n        {{- end }}\n     )\n    {{- end }}\n\n    {{- if hasMsgComment .Model \"@index\" }}\n    {{ $define }}.Indexes = append(\n        {{ $define }}.Indexes,\n        {{- range .Fields }}\n            {{- if hasComment .Comment \"@index\" }}\n             \"index;{{ getIndexComment .Comment \"@index\" 0 (join .JSONName \"_idx\") }};{{ replace (getIndexComment .Comment \"@index\" 1 (join \"(\" .JSONName \")\")) \";\" \",\" }}\",\n            {{- end }}\n        {{- end }}\n     )\n    {{- end }}\n\n    {{- if hasMsgComment .Model \"@unique\" }}\n    {{ $define }}.Indexes = append(\n        {{ $define }}.Indexes,\n        {{- range .Fields }}\n            {{- if hasComment .Comment \"@unique\" }}\n             \"unique index;{{ getIndexComment .Comment \"@unique\" 0 (join .JSONName \"_idx\") }};{{ replace (getIndexComment .Comment \"@unique\" 1 (join \"(\" .JSONName \")\")) \";\" \",\" }}\",\n            {{- end }}\n        {{- end }}\n     )\n    {{- end }}\n}\n\nfunc New{{ $modelName }}(fields contracts.Fields) *{{ $modelName }} {\n  var model = {{ $modelName }}{\n    _raw: fields,\n  }\n  model.Set(fields)\n  return &model\n}\n\nfunc {{ $modelName }}SingleRelationSetter[T any](key contracts.RelationType) func(item *{{ $modelName }}, value []any) {\n    return func(item *{{ $modelName }}, values []any) {\n        var value T\n        if len(values) > 0 {\n            value = values[0].(T)\n        }\n        item.Set(contracts.Fields{\n            string(key): value,\n        })\n    }\n}\nfunc {{ $modelName }}MultiRelationSetter[T any](key contracts.RelationType) func(item *{{ $modelName }}, value []any) {\n    return func(model *{{ $modelName }}, value []any) {\n        var results []T\n        for _, item := range value {\n            results = append(results, item.(T))\n        }\n        model.Set(contracts.Fields{ string(key): results })\n    }\n}\n\nfunc {{ $modelName }}LocalKeyGetter(key string) func(item *{{ $modelName }}) any {\n    return func(item *{{ $modelName }}) any {\n        return item.Get(key)\n    }\n}\n\nfunc {{ $modelName }}RelationGetter[T any](query func() *table.Table[T], foreignKey string) func(keys []any) map[string][]any {\n    return func(keys []any) map[string][]any {\n        var results = map[string][]any{}\n        for key, values := range query().WhereIn(foreignKey, keys).Get().GroupBy(foreignKey) {\n            results[key] = collection.New(values).ToAnyArray()\n        }\n        return results\n    }\n}\n\nfunc {{ $modelName }}ThroughRelationGetter[T any](query func() *table.Table[T], midTable, firstKey, secondKey, secondLocalKey string) func(keys []any) map[string][]any {\n    return func(keys []any) map[string][]any {\n        var results = map[string][]any{}\n        groupKey := fmt.Sprintf(\"%s.%s\", midTable, firstKey)\n        for key, values := range query().\n            AddSelect(fmt.Sprintf(\"(%s) as _group_key\", groupKey)).\n            WhereIn(groupKey, keys).\n            Join(midTable, fmt.Sprintf(\"%s.%s\", midTable, secondLocalKey), \"=\", fmt.Sprintf(\"%s.%s\", query().GetTableName(), secondKey)).\n            Get().GroupBy(\"_group_key\") {\n            results[key] = collection.New(values).ToAnyArray()\n        }\n        return results\n    }\n }\n\n{{- $queryName := replace .Model.Name \"Model\" \"Query\" }}\nfunc {{ $queryName }}WithExecutor(executor contracts.SqlExecutor) *table.Table[{{ $modelName }}] {\n    return {{ $queryName }}().SetExecutor(executor)\n}\n\nfunc {{ $queryName }}() *table.Table[{{ $modelName }}] {\n  return table.NewQuery({{ $define }}.TableName, New{{ $modelName }}).\n    SetPrimaryKey(\"{{ $primaryKey }}\").\n    {{- if hasMsgComment .Model \"@timestamps\" }}\n    SetCreatedTimeColumn(\"{{ getIndexComment .Model.Comment \"@timestamps\" 0 \"created_at\" }}\").\n    SetUpdatedTimeColumn(\"{{ getIndexComment .Model.Comment \"@timestamps\" 1 \"updated_at\" }}\").\n    {{- end }}\n    {{- range $index, $item := .Relations }}\n        {{- $relationType := join $rawName  .Name \"Relation\" }}\n        {{- $relationItemType := substring (goType .) 1 }}\n        {{- $relationQuery := replace $relationItemType \"Model\" \"Query\"}}\n\n        {{- if .Repeated }}\n        {{- $relationItemType = substring (goType .) 2 }}\n        {{- $relationQuery = substring $relationQuery 2 }}\n        {{- end }}\n\n\n        {{- if hasComment .Comment \"@belongsTo\" }}\n            {{- $ownerKey := getIndexComment .Comment \"@belongsTo\" 0 \"id\" }}\n            {{- $localKey := getIndexComment .Comment \"@belongsTo\" 1 (join .JSONName \"_id\") }}\n            SetRelation( // belongsTo: {{ .Name }}\n            {{ $rawName }}{{ .Name }}Relation,\n                        {{ $modelName }}LocalKeyGetter(\"{{ $localKey }}\"),\n                        {{ $modelName }}RelationGetter({{ $relationQuery }}, \"{{ $ownerKey }}\"),\n                        {{ $modelName }}SingleRelationSetter[*{{ $relationItemType }}]({{ $relationType }}),\n            ).\n        {{- else if hasComment .Comment \"@hasOneThrough\" }}\n\n         {{- $midTable := getIndexComment .Comment \"@hasOneThrough\" 0 \"mid_table\" }}\n         {{- $firstKey := getIndexComment .Comment \"@hasOneThrough\" 1 (join (toLower $rawName) \"_id\") }}\n         {{- $secondKey := getIndexComment .Comment \"@hasOneThrough\" 2 \"id\" }}\n         {{- $localKey := getIndexComment .Comment \"@hasOneThrough\" 3 \"id\" }}\n         {{- $secondLocalKey := getIndexComment .Comment \"@hasOneThrough\" 4 (join $midTable \"_id\") }}\n\n                    SetRelation( // hasOneThrough: {{ .Name }}\n                    {{ $rawName }}{{ .Name }}Relation,\n                        {{ $modelName }}LocalKeyGetter(\"{{ $localKey }}\"),\n                        {{ $modelName }}ThroughRelationGetter({{ $relationQuery }}, \"{{ $midTable }}\", \"{{ $firstKey }}\", \"{{ $secondKey }}\", \"{{ $secondLocalKey }}\"),\n                        {{ $modelName }}SingleRelationSetter[*{{ $relationItemType }}]({{ $relationType }}),\n                    ).\n        {{- else if hasComment .Comment \"@hasOne\" }}\n         {{- $localKey := getIndexComment .Comment \"@hasOne\" 0 \"id\" }}\n         {{- $foreignKey := getIndexComment .Comment \"@hasOne\" 1 (join (toLower $rawName) \"_id\") }}\n                    SetRelation( // hasOne: {{ .Name }}\n                    {{ $rawName }}{{ .Name }}Relation,\n                        {{ $modelName }}LocalKeyGetter(\"{{ $localKey }}\"),\n                        {{ $modelName }}RelationGetter({{ $relationQuery }}, \"{{ $foreignKey }}\"),\n                        {{ $modelName }}SingleRelationSetter[*{{ $relationItemType }}]({{ $relationType }}),\n                    ).\n        {{- else if or (hasComment .Comment \"@hasManyThrough\") (hasComment .Comment \"@belongsToMany\") }}\n\n            {{- $relationName := \"hasManyThrough\" }}\n            {{- if (hasComment .Comment \"@belongsToMany\") }}\n            {{- $relationName = \"belongsToMany\" }}\n            {{- end }}\n\n         {{- $midTable := getIndexComment .Comment (join \"@\" $relationName) 0 \"mid_table\" }}\n         {{- $firstKey := getIndexComment .Comment (join \"@\" $relationName) 1 (join (toLower $rawName) \"_id\") }}\n         {{- $secondKey := getIndexComment .Comment (join \"@\" $relationName) 2 \"id\" }}\n         {{- $localKey := getIndexComment .Comment (join \"@\" $relationName) 3 \"id\" }}\n         {{- $secondLocalKey := getIndexComment .Comment (join \"@\" $relationName) 4 (join $midTable \"_id\") }}\n\n                    SetRelation( // {{- $relationName }}: {{ .Name }}\n                    {{ $rawName }}{{ .Name }}Relation,\n                        {{ $modelName }}LocalKeyGetter(\"{{ $localKey }}\"),\n                        {{ $modelName }}ThroughRelationGetter({{ $relationQuery }}, \"{{ $midTable }}\", \"{{ $firstKey }}\", \"{{ $secondKey }}\", \"{{ $secondLocalKey }}\"),\n                        {{ $modelName }}MultiRelationSetter[{{ $relationItemType }}]({{ $relationType }}),\n                    ).\n        {{- else if hasComment .Comment \"@hasMany\" }}\n         {{- $relationItemType := substring (goType .) 2 }}\n         {{- $relationQuery := replace (substring (goType .) 3) \"Model\" \"Query\"}}\n         {{- $foreignKey := getIndexComment .Comment \"@hasMany\" 0 (join (toLower $rawName) \"_id\") }}\n         {{- $localKey := getIndexComment .Comment \"@hasMany\" 1 \"id\" }}\n                    SetRelation( // hasMany: {{ .Name }}\n                    {{ $rawName }}{{ .Name }}Relation,\n                        {{ $modelName }}LocalKeyGetter(\"{{ $localKey }}\"),\n                        {{ $modelName }}RelationGetter({{ $relationQuery }}, \"{{ $foreignKey }}\"),\n                        {{ $modelName }}MultiRelationSetter[{{ $relationItemType }}]({{ $relationType }}),\n                    ).\n        {{- end }}\n\n    {{- end }}\n     SetWiths({{ $define }}.With...)\n}\n\nfunc (model *{{ $modelName }}) Hidden(fields ...string) *{{ $modelName }} {\n    for _, field := range fields {\n        if model._hidden == nil {\n            model._hidden = map[string]struct{}{\n                field: struct{}{},\n            }\n        } else {\n            model._hidden[field] = struct{}{}\n        }\n\n    }\n\n    return model\n}\n\nfunc (model *{{ $modelName }}) Exists() bool {\n  return {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).Count() > 0\n}\n\nfunc (model *{{ $modelName }}) Save() contracts.Exception {\n  if model._update == nil {\n    return nil\n  }\n  if {{ $define }}.Saving != nil {\n    if err := {{ $define }}.Saving(model); err != nil {\n      return err\n    }\n  }\nvar err contracts.Exception\nvar pk = model. GetPrimaryKey()\nif cast.ToUint64(pk) == 0 {\n    pk, err = {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).InsertGetIdE(model._update)\n    if err == nil {\n        {{- range .Fields }}\n        {{- if eq .JSONName $primaryKey }}\n        model.Set{{.Name}}(cast.{{ convertFunc (goType .) }}(pk))\n        {{- end }}\n        {{- end }}\n    }\n} else {\n  _, err = {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).UpdateE(model._update)\n}\n  if err == nil {\n    model._update = nil\n    if {{ $define }}.Saved != nil {\n      {{ $define }}.Saved(model)\n    }\n  }\n\n  return err\n}\n\nfunc (model *{{ $modelName }}) Set(fields contracts.Fields) {\n  for key, value := range fields {\n\n    switch key {\n  {{- range .Fields }}\n      case \"{{ .JSONName }}\":\n        switch v := value.(type) {\n                case {{ goType . }}:\n                  model.Set{{ .Name }}(v)\n                case func() {{ goType . }}:\n                  model.Set{{ .Name }}(v())\n                  {{- $type := goType . }}\n                  {{- if ne $type \"string\"}}\n                case string:\n                  {{- if eq $type \"[]byte\" }}\n                  model.Set{{ .Name }}([]byte(v))\n                  {{else}}\n                  var vd {{ goType . }}\n                  err := json.Unmarshal([]byte(v), &vd)\n                  if err != nil {\n                      logs.Default().Warn(\"Failed to Parse field \"+key)\n                      continue\n                  }\n                  model.Set{{ .Name }}(vd)\n                  {{end}}\n                  {{end}}\n                  {{- if ne $type \"[]byte\"}}\n                case []byte:\n                  {{- if eq $type \"string\" }}\n                  model.Set{{ .Name }}(string(v))\n                  {{else}}\n                  var vd {{ goType . }}\n                  err := json.Unmarshal(v, &vd)\n                  if err != nil {\n                      logs.Default().Warn(\"Failed to Parse field \"+key)\n                      continue\n                  }\n                  model.Set{{ .Name }}(vd)\n                  {{end}}\n                  {{end}}\n                {{- if isBasicType . }}\n                default:\n                    model.Set{{ .Name }}(cast.{{ convertFunc (goType .) }}(v))\n                {{- end }}\n                }\n    {{- end }}\n    {{- range .Relations }}\n    {{- $relationType := join $rawName  .Name \"Relation\" }}\n    case string({{ $relationType }}):\n        model.Set{{ .Name }}(value.({{ goType . }}))\n    {{- end }}\n    }\n\n  }\n}\n\nfunc (model *{{ $modelName }}) Only(key ...string) contracts.Fields {\n  var fields = make(contracts.Fields)\n  for _, k := range key {\n  {{- range .Fields }}\n    if k == \"{{ .JSONName }}\" {\n      fields[k] = model.Get{{ .Name }}()\n      continue\n    }\n  {{- end }}\n\n    if {{ $define }}.Appends[k] != nil {\n     fields[k] = {{ $define }}.Appends[k](model)\n    }\n  }\n  return fields\n}\n\nfunc (model *{{ $modelName }}) Get(key string) any {\n    switch key {\n        {{- range $index, $item := .Fields }}\n            case \"{{ .JSONName }}\":\n              return model.Get{{ .Name }}()\n        {{- end }}\n    }\n\n    if value, exists := model._append[key]; exists {\n      return value\n    }\n\n    if fn, exists := {{ $define }}.Appends[key]; exists {\n        model._append[key] = fn(model)\n      return model._append[key]\n    }\n\n     switch contracts.RelationType(key) {\n            {{- range $index, $item := .Relations }}\n            {{- $relationType := join $rawName  .Name \"Relation\" }}\n                case {{ $relationType }}:\n                  return model.{{ .Name }}()\n            {{- end }}\n        }\n\n  return nil\n}\n\nfunc (model *{{ $modelName }}) Except(keys ...string) contracts.Fields {\n  var excepts = map[string]struct{}{}\n  for _, k := range keys {\n    excepts[k] = struct{}{}\n  }\n  var fields = make(contracts.Fields)\n  for key, value := range model.ToFields() {\n    if _, ok := excepts[key]; ok {\n      continue\n    }\n    fields[key] = value\n  }\n  return fields\n}\n\nfunc (model *{{ $modelName }}) ToFields() contracts.Fields {\n    if model == nil {\n        return nil\n    }\n\n  model.Hidden({{ $define }}.Hidden...)\n\n  fields := contracts.Fields{}\n\n    {{- range .Fields }}\n    if _,exists := model._hidden[\"{{ .JSONName }}\"]; !exists {\n        fields[\"{{ .JSONName }}\"] = model.Get{{ .Name }}()\n    }\n    {{- end }}\n\n  for key := range {{ $define }}.Appends {\n    value := model.Get(key)\n    if fieldsProvider, ok := value.(contracts.FieldsProvider); ok {\n        fields[key] = fieldsProvider.ToFields()\n    } else {\n        fields[key] = value\n    }\n  }\n\n  for key := range model._relation_loaded {\n    switch key {\n    {{- range .Relations }}\n    {{- $relationType := join $rawName  .Name \"Relation\" }}\n    case {{ $relationType }}:\n        {{- if .Repeated }}\n        var results []contracts.Fields\n        for _, item := range model._{{ .Name }} {\n            results = append(results, item.ToFields())\n        }\n        fields[string(key)] = results\n        {{- else }}\n        fields[string(key)] = model._{{ .Name }}.ToFields()\n        {{- end }}\n    {{- end }}\n    }\n  }\n\n  for key, value := range model._raw {\n    _, hidden := model._hidden[key]\n    if _, exists := fields[key]; !exists && !hidden {\n        fields[key] = value\n    }\n  }\n\n  return fields\n}\n\nfunc (model *{{ $modelName }}) Update(fields contracts.Fields) contracts.Exception {\n\n  if {{ $define }}.Updating != nil {\n    if err := {{ $define }}.Updating(model, fields); err != nil {\n      return err\n    }\n  }\n\n  if model._update != nil {\n    utils.MergeFields(model._update, fields)\n  }\n\n\n  _, err := {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).UpdateE(fields)\n\n  if err == nil {\n    model.Set(fields)\n    model._update = nil\n    if {{ $define }}.Updated != nil {\n      {{ $define }}.Updated(model, fields)\n    }\n  }\n\n  return err\n}\n\nfunc (model *{{ $modelName }}) Refresh() contracts.Exception {\n  fields, err := table.ArrayQuery(\"{{ $tableName }}\").Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).FirstE()\n  if err != nil {\n    return err\n  }\n\n  model.Set(*fields)\n  return nil\n}\n\nfunc (model *{{ $modelName }}) Delete() contracts.Exception {\n\n  if {{ $define }}.Deleting != nil {\n    if err := {{ $define }}.Deleting(model); err != nil {\n      return err\n    }\n  }\n\n  _, err := {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).DeleteE()\n  if err == nil && {{ $define }}.Deleted != nil {\n    {{ $define }}.Deleted(model)\n  }\n\n  return err\n}\n\n\nfunc (model *{{ $modelName }}) GetPrimaryKey() any {\n  if {{ $define }}.PrimaryKeyGetter != nil {\n    return {{ $define }}.PrimaryKeyGetter(model)\n  }\n\n  return model.{{ toCamelCase $primaryKey }}\n}\n\n{{- if .Model.Authenticatable }}\nfunc (model *{{ $modelName }}) GetAuthenticatableKey() string {\n  return fmt.Sprintf(\"%v\", model.GetPrimaryKey())\n}\n\nfunc {{ .Model.RawName }}AuthProvider(identify string) contracts.Authenticatable {\n  return {{ .Model.RawName }}Query().Find(identify)\n}\n\n{{- end }}\n\n\n{{- range .Fields }}\n\nfunc (model *{{ $modelName }}) Get{{ .Name }}() {{ goType . }} {\n  if {{ $define }}.{{ .Name }}Getter != nil {\n    return {{ $define }}.{{ .Name }}Getter(model, model.{{ .Name }})\n  }\n  return model.{{ .Name }}\n}\n\nfunc (model *{{ $modelName }}) Set{{ .Name }}(value {{ goType . }}) {\n  if {{ $define }}.{{ .Name }}Setter != nil {\n    value = {{ $define }}.{{ .Name }}Setter(model, value)\n  }\n\n  if model._update == nil {\n    model._update = contracts.Fields{\"{{ .JSONName }}\": value}\n  } else {\n    model._update[\"{{ .JSONName }}\"] = value\n  }\n  model.{{ .Name }} = value\n}\n\n{{- if hasComment .Comment \"@carbon\" }}\nfunc (model *{{ $modelName }}) Get{{ .Name }}Carbon() carbon.Carbon {\n  return carbon.Parse(model.Get{{ .Name }}())\n}\n{{- end }}\n\n\n{{- end }}\n\n{{- range .Relations }}\n{{- $relationType := join $rawName  .Name \"Relation\" }}\n{{- $relationItemType := substring (goType .) 1 }}\n{{- $relationQueryType := substring (goType .) 1 }}\n{{- $throughName := \"\" }}\n\n{{- if .Repeated }}\n{{- $relationItemType = substring (goType .) 3 }}\n{{- $relationQueryType = substring (goType .) 3 }}\n{{- end }}\n\n\n{{- $relationQuery := replace $relationItemType \"Model\" \"Query\" }}\n{{- $foreignKey := \"\" }}\n{{- $localKey := \"\" }}\n{{- $localQuery := join .Name \"Query\" }}\n\n{{- if (hasComment .Comment \"@belongsTo\") }}\n{{- $throughName = \"@belongsTo\" }}\n{{- $foreignKey = getIndexComment .Comment \"@belongsTo\" 0 \"id\" }}\n{{ $localKey = getIndexComment .Comment \"@belongsTo\" 1 (join .JSONName \"_id\") }}\n\n{{- else if (hasComment .Comment \"@hasOne\") }}\n{{- $throughName = \"@hasOne\" }}\n\n{{- $localKey = getIndexComment .Comment \"@hasOne\" 0 \"id\" }}\n{{- $foreignKey = getIndexComment .Comment \"@hasOne\" 1 (join (toLower $rawName) \"_id\") }}\n\n{{- else if (hasComment .Comment \"@hasMany\") }}\n{{- $throughName = \"@hasMany\" }}\n\n{{- $relationQuery = replace $relationItemType \"Model\" \"Query\" }}\n{{- $foreignKey = getIndexComment .Comment \"@hasMany\" 0 (join .JSONName \"_id\") }}\n{{- $localKey = getIndexComment .Comment \"@hasMany\" 1 \"id\" }}\n{{- $relationQueryType = $relationItemType }}\n\n{{- end }}\n\n{{- if .Repeated }}\n// {{ $localQuery }} {{ $throughName }}\nfunc (model *{{ $modelName }}) {{ .Name }}() {{ goType . }} {\n    _, exists := model._relation_loaded[{{ $relationType }}]\n    if !exists {\n        value := model.{{ $localQuery }}().Get().ToArray()\n        model.Set{{ .Name }}(value)\n        return value\n    }\n    return model._{{ .Name }}\n}\n\n{{- else }}\n// {{ $localQuery }} {{ $throughName }}\nfunc (model *{{ $modelName }}) {{ .Name }}() {{ goType . }} {\n    _, exists := model._relation_loaded[{{ $relationType }}]\n    if !exists {\n        value := model.{{ $localQuery }}().First()\n        model.Set{{ .Name }}(value)\n        return value\n    }\n    return model._{{ .Name }}\n}\n{{- end }}\n\n\n{{- if or (hasComment .Comment \"@hasManyThrough\") (hasComment .Comment \"@belongsToMany\") (hasComment .Comment \"@hasOneThrough\")  }}\n\n{{- $throughName := \"@hasManyThrough\" }}\n\n{{- if (hasComment .Comment \"@belongsToMany\") }}\n{{- $throughName = \"@belongsToMany\" }}\n{{- else if (hasComment .Comment \"@hasOneThrough\") }}\n{{- $throughName = \"@hasOneThrough\" }}\n{{- end }}\n\n\n{{- $midTable := getIndexComment .Comment $throughName 0 \"mid_table\" }}\n{{- $firstKey := getIndexComment .Comment $throughName 1 (join (toLower $rawName) \"_id\") }}\n{{- $secondKey := getIndexComment .Comment $throughName 2 \"id\" }}\n{{- $localKey := getIndexComment .Comment $throughName 3 \"id\" }}\n{{- $secondLocalKey := getIndexComment .Comment $throughName 4 (join $midTable \"_id\") }}\n// {{ $localQuery }} {{ $throughName }}\nfunc (model *{{ $modelName }}) {{ $localQuery }}() contracts.QueryBuilder[{{ $relationQueryType }}] {\n    query := {{ $relationQuery }}()\n    return query.\n        Where(\"{{ $midTable }}.{{ $firstKey }}\", model.Get(\"{{ $localKey }}\")).\n        Join(\"{{ $midTable }}\", \"{{ $midTable }}.{{ $secondLocalKey }}\",  \"=\", fmt.Sprintf(\"%s.{{ $secondKey }}\", query.GetTableName()))\n}\n\n{{- else }}\n// {{ $localQuery }} {{ $throughName }}\nfunc (model *{{ $modelName }}) {{ $localQuery }}() contracts.QueryBuilder[{{ $relationQueryType }}] {\n    return {{ $relationQuery }}().Where(\"{{ $foreignKey }}\", model.Get(\"{{ $localKey }}\"))\n}\n{{- end }}\n\n// {{ $localQuery }} {{ $throughName }}\nfunc (model *{{ $modelName }}) Set{{ .Name }}(value {{ goType . }}) {\n    if model._relation_loaded == nil {\n        model._relation_loaded = make(map[contracts.RelationType]struct{})\n    }\n    model._relation_loaded[{{ $relationType }}] = struct{}{}\n    model._{{ .Name }} = value\n}\n\n{{- end }}\n\n{{ end }}\n\n\n{{- define \"data\" -}}\npackage {{ .Package }}\n\nimport (\n{{- range .Imports }}\n{{ .Alias }} \"{{ .Pkg }}\"\n{{- end }}\n)\n\ntype {{ .Model.Name }} struct {\n  {{- range .Fields }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n}\n\n{{ end }}\n\n{{- define \"request\" -}}\npackage {{ .Package }}\n\nimport (\n  {{- range .Imports }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{- end }}\n  \"github.com/goal-web/contracts\"\n)\n\ntype {{ .Model.Name }} struct {\n  {{- range .Fields }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n}\n\nfunc (model *{{ .Model.Name }}) ToFields() contracts.Fields {\n  if model == nil {\n    return nil\n  }\n  fields := contracts.Fields{\n  {{- range .Fields }}\n    \"{{ .JSONName }}\": model.{{ .Name }},\n  {{- end }}\n  }\n  return fields\n}\n\n{{ end }}\n\n{{- define \"result\" -}}\npackage {{ .Package }}\n\nimport (\n    \"github.com/goal-web/contracts\"\n  {{- range .Imports }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{- end }}\n)\n\n{{- $resultName := .Model.Name }}\n\ntype {{ $resultName }} struct {\n  {{- range .Fields }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n}\n\nfunc (result *{{ $resultName }}) ToFields() contracts.Fields {\n\n    fields := contracts.Fields{\n        {{- range .Fields }}\n            {{- if eq (fieldMsg .) nil }}\n            \"{{ .JSONName }}\": result.{{ .Name }},\n            {{- else if and (ne .Repeated true) .IsModel }}\n            \"{{ .JSONName }}\": result.{{ .Name }}.ToFields(),\n            {{- else }}\n            \"{{ .JSONName }}\": result.{{ .Name }},\n            {{- end }}\n        {{- end }}\n    }\n\n    {{- range .Fields }}\n        {{- if and .Repeated (ne (fieldMsg .) nil) (fieldMsg .).IsModel }}\n        {{ .JSONName }}List := make([]contracts.Fields, len(result.{{ .Name }}))\n        for i, item := range result.{{ .Name }} {\n            {{ .JSONName }}List[i] = item.ToFields()\n        }\n        fields[\"{{ .JSONName }}\"] = {{ .JSONName }}List\n        {{- end }}\n    {{- end }}\n\n\n    return fields\n}\n\n{{ end }}\n\n{{- define \"enum\" -}}\npackage {{ .Package }}\n\n{{- $enumName := .Name }}\ntype {{ .Name }} int\nconst (\n  {{- range .Values }}\n  {{- $FieldName := sprintf \"%s%s\" $enumName .Name }}\n\n  {{ toComments $FieldName .Comments }}\n  {{ $enumName }}{{ .Name }} {{ $enumName }} = {{ .Value }}\n  {{- end }}\n  {{ $enumName }}Unknown {{ $enumName }} = -1000\n\n)\n\n\nfunc (item {{ $enumName }}) String() string {\n    switch item {\n      {{- range .Values }}\n        case {{ $enumName }}{{ .Name }}:\n          return \"{{ .Name }}\"\n      {{- end }}\n        default:\n          return \"Unknown\"\n  }\n}\n\nfunc (item {{ $enumName }}) Message() string {\n    switch item {\n      {{- range .Values }}\n        case {{ $enumName }}{{ .Name }}:\n          return \"{{ .Message }}\"\n      {{- end }}\n        default:\n          return \"Unknown\"\n  }\n}\n\nfunc Parse{{ $enumName }}FromString(msg string) {{ $enumName }} {\n    switch msg {\n    {{- range .Values }}\n        case \"{{ .Name }}\":\n          return {{ $enumName }}{{ .Name }}\n    {{- end }}\n        default:\n          return {{ $enumName }}Unknown\n  }\n}\n\n\n{{ end }}\n\n\n\n{{- define \"service\" -}}\npackage {{ .Package }}\n\nimport (\n    \"github.com/goal-web/contracts\"\n  {{- range .Imports }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{- end }}\n)\n\n{{- $serviceName := .Name }}\n{{- $define := join .Name \"Define\" }}\n\nvar {{ $define }} {{ $serviceName }}Static\ntype  {{ $serviceName }}Static struct {\n{{- range .Methods }}\n    {{ .Name }} func (req *{{ .InputUsageName }}, ctx contracts.Context) (*{{ .OutputUsageName }}, error)\n{{- end }}\n}\n\n{{- range .Methods }}\n\nfunc {{ $serviceName }}{{ .Name }}(req *{{ .InputUsageName }}, ctx contracts.Context) (*{{ .OutputUsageName }}, error) {\n  if {{ $define }}.{{ .Name }} != nil {\n    return {{ $define }}.{{ .Name }}(req, ctx)\n  }\n  return nil, nil\n}\n{{- end }}\n{{ end }}\n\n\n{{- define \"controller\" -}}\npackage {{ .Package }}\n\nimport (\n  \"github.com/goal-web/contracts\"\n  \"github.com/goal-web/validation\"\n  \"{{ .ResponsePath }}\"\n  svc \"{{ .ImportPath }}\"\n  {{- range .Imports }}\n  {{- if notContains .Pkg \"results\" }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{ end -}}\n  {{- end }}\n)\n\n{{- $serviceName := .Name }}\n{{- $prefix := .Prefix }}\nfunc {{ .Name }}Router(router contracts.HttpRouter) {\n  routeGroup := router.Group(\"{{ $prefix }}\"{{ toMiddlewares .Middlewares }})\n  {{- range .Methods }}\n  {{- $controllerMethod := sprintf \"%s%s\" $serviceName .Name  }}\n  {{- $path := .Path  }}\n  {{- $middlewares := .Middlewares }}\n    {{- range .Method }}\n    routeGroup.{{ . }}(\"{{ $path }}\", {{ $controllerMethod }}{{ toMiddlewares $middlewares }})\n    {{- end }}\n  {{- end }}\n}\n\n\n{{- $usageName := .UsageName }}\n\n{{- range .Methods }}\nfunc {{ $serviceName }}{{ .Name }}(request contracts.HttpRequest) any {\n    var req {{ .InputUsageName }}\n\n    if err:= request.Parse(&req); err != nil {\n      return response.ParseReqErr(err)\n    }\n\n    if err := validation.Struct(req); err != nil {\n      return response.InvalidReq(err)\n    }\n\n    resp, err := {{ $usageName }}{{ .Name }}(&req, request)\n    if err != nil {\n      return response.BizErr(err)\n    }\n\n    return response.Success(resp)\n}\n{{- end }}\n{{ end }}")

func GetTemplate(path string) *template.Template {
	// 读取模板文件
	tmplContent, err := os.ReadFile(path)
	if err != nil {
		logs.Default().WithField("path", path).Warn("模板文件不存在，将使用默认模板")
		tmplContent = defaultTemplate
	}

	// 初始化模板，并添加函数映射
	tmpl, err := template.New("codegen").Funcs(template.FuncMap{
		"sub":             Sub,
		"convertFunc":     ConvertFunc,
		"isBasicType":     IsBasicType,
		"goType":          GoType,
		"toLower":         strings.ToLower,
		"toCamelCase":     ToCamelCase,
		"toSnake":         ToSnakeCase,
		"toTags":          ToTags,
		"tsType":          TsType,
		"replace":         strings.ReplaceAll,
		"toComments":      ToComments,
		"sprintf":         fmt.Sprintf,
		"contains":        strings.Contains,
		"notContains":     NotContains,
		"toMiddlewares":   ToMiddlewares,
		"getComment":      GetComment,
		"join":            StringJoin,
		"getIndexComment": GetIndexComment,
		"hasComment":      HasComment,
		"substring":       SubString,
		"fieldMsg":        FieldMsg,
		"hasMsgComment":   HasMsgComment,
	}).Parse(string(tmplContent))
	if err != nil {
		log.Fatal(err)
	}
	return tmpl
}
